%!TEX root = ../main.tex

Com base nos protocolos usados nas redes MANET atuais, propomos um protocolo
completamente distribuído, que trata a tradução de nomes como um serviço na rede
em que está inserido. Esse protocolo, \textit{FDNS-SD} -- 
\textit{Fully Distributed Name Service - Service Discovery} --, atua tanto em
tradução de nomes quanto em descoberta de serviço.

Este capítulo descreve o funcionamento do \textit{FDNS-SD}, bem como os conceitos
e a terminologia usada. O protocolo sendo descrito ainda é puramente teórico,
portanto seu desempenho não foi avaliado.

\subsection{Especificações}
    \subsubsection{Conceitos iniciais}
        \begin{enumerate}
            \item Vizinhança -- quase todos os floods realizados pelo FDNS-SD são
            controlados. Inicialmente é definido um número máximo de saltos; as
            máquinas  encontradas dentro desse limite constituem a vi\-zi\-nhan\-ça
            de um nó.
            \item Servidor de nomes -- são máquinas que oferecem o serviço de
            tradução de nomes. A tradução é um serviço como qualquer outro na rede.
            Os servidores de nomes do FDNS-SD guardam o mínimo de informação
            necessária, de modo que essa informação possa ser recriada se necessário.
            Qualquer máquina pode se tornar e deixar de ser um servidor de nomes
            a qualquer momento.
            \item Time to Live (TTL) -- todas as informações são válidas por um 
            tempo máximo \textbf{T}, que depende da mobilidade e volatilidade da
            rede. Quanto mais rápida a rede, menor o tempo \textbf{T}.
        \end{enumerate}
        
    \subsection{Algoritmo de criação de servidores}
        \begin{enumerate}
            \item Quando uma máquina \textbf{A} precisa traduzir um nome, ela
            busca em sua vizinhança se existe algum servidor de nomes. Se existir,
            ela usa esse servidor.
            \item Caso não exista servidor, essa máquina \textbf{A} torna-se um 
            servidor de nomes.
            \item \textbf{A} então faz um broadcast em sua vizinhança para montar
            sua tabela de nomes. As vizinhas de \textbf{A} sabem então que existe
            um servidor de nomes por um tempo \textbf{T}. Se o nome buscado por
            \textbf{A} for encontrado, o processo chega ao fim.
            \item Caso contrário, a máquina \textbf{A} envia um broadcast à rede
            buscando outros servidores de nomes, e inclui nessa mensagem qual nome
            ela quer traduzido (nome que originou todo o processo para a criação
            do servidor). Qualquer servidor de nomes que receber esse broadcast
            deve guardar o IP e o nome da máquina \textbf{A} em sua tabela de
            servidores de nomes conhecidos, e deve responder a ela em unicast com
            seu próprio nome e IP. Caso algum servidor conheça a tradução do nome
            buscado por \textbf{A}, deve incluir a tradução no unicast de resposta.
            \item Caso \textbf{A} descubra ser o único servidor de nomes na rede,
            ou não encontre a tradução do nome que procura, deve então enviar
            outro broadcast à rede com o nome buscado. Ao receber o pedido de
            tradução, a máquina com o nome procurado envia o seu IP em unicast
            para \textbf{A}, e \textbf{pode} então se tornar ela mesma um servidor
            de nomes (dependendo do seu nível de energia, por exemplo), visto que
            esse flood indica que não existem servidores de nomes próximos.
            \item A cada intervalo de tempo \textbf{T}, o servidor \textbf{A}
            verifica a vizinhança e atualiza sua tabela, deletando entradas expiradas
            e inserindo as novas. A tabela de servidores não está sujeita a um TTL.
            \item Quando uma máquina nova entra na rede, deve buscar um servidor
            de DNS vizinho para informar seus dados e ser incluído na tabela de
            tradução.
        \end{enumerate}
    
    \subsection{Algoritmo de tradução de nomes}
        \begin{enumerate}
            \item Dado que uma máquina \textbf{M} conhece um servidor de nomes
            \textbf{S} próximo a ela, e \textbf{M} quer a tradução de um nome,
            então \textbf{M} envia à \textbf{S} um pedido de tradução.
            \item Caso \textbf{S} conheça a tradução pedida, devolve essa resposta
            à \textbf{M}. Caso contrário, \textbf{S} envia um multicast à todos
            os servidores em sua tabela de servidores. Se algum outro servidor
            puder traduzir o nome, devolve essa resposta à \textbf{S}, que devolve
            à \textbf{M}. Caso alguma máquina tenha deixado de ser servidor,
            informa isso à \textbf{S}. Todo servidor que não for capaz de traduzir
            o nome, simplesmente ignora a mensagem de \textbf{S}.
            \item Se receber uma resposta do multicast, \textbf{S} a repassa à
            \textbf{M}.
            \item Se não receber resposta, \textbf{S} inicia um broadcast buscando
            pela tradução. Ao ser atingida pelo broadcast, a máquina buscada
            responde em unicast à \textbf{S}, e, como já descrito anteriormente,
            pode se tornar um servidor de nomes, dependendo do seu nível de energia.
        \end{enumerate}
    